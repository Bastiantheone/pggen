// package include defines include specs, which represent a subset of the
// object graph in the database. They can be used to instruct the code
// generated by pggen to load child entities attached to a given entity
// by a 1-1, 1-* or *-* relationship in an efficient way that avoids N+1 queries.
//
// In order to make defining include specs more convenient, they have a simple
// textual syntax for describing them. The syntax for include specs is reminiscent
// of dot access syntax, except that multiple tables can be accessed at once. For
// example, if you had an `foos` table that had a 1-* relationship with a `bars`
// table, you could use the following to produce an `include.Spec` to efficiently
// load all the bars attached to a foo:
//
// ```go
// spec := include.Must(include.Parse("foos.bars"))
// ```
//
// Dot access syntax works well enough when a table has just a single
// relationship, but it doesn't handle relationships with multiple tables,
// so include spec syntax allows you to write a list of sub-specs separated
// by commas and enclosed in a set of curly braces.
//
// For example, if the `foos` table also had a `bazes` attached to it with a 1-*
// relationship and the `bars` table had a `quxes` table attached to
// it in the same way, you could use to following to create a spec
// for loading all the objects attached to a given foo, even transitively.
//
// ```go
// spec := include.Must(include.Parse("foos.{bars.quxes, bazes}"))
// ```
//
// In order to match the semantics of SQL, include specs allow quoted
// identifiers, so the spec `"space table".{"how odd", "right?"}` is
// a valid include spec. Just like in SQL, you can escape a `"` in a
// quoted identifier with `""`.
//
// More formally, the grammar for include specs is:
//
// spec ::= id
//        | id '.' spec
//        | id '.' '{' spec_list '}'
// spec_list ::= spec
//             | spec ',' spec
//
// Cyclic Include Specs:
//
// The object graph in a database schema might have cyclic references, which don't
// map the most obviously to the hierarchical representation used by include specs,
// especially in their textual form. Include specs can still be used to describe
// cycles though. Each cycle in an include spec has a root node, which is the one
// closest to the root node of the include spec. Cycles are expressed as the path
// from the root node back to itself.
//
// For example, if the table `foo` referenced the table `bar` which contained a
// reference back to `foo`, the include spec `foo.bar.foo` could be used to capture
// that cycle.
package include

import (
	"fmt"
	"math"
	"regexp"
	"sort"
	"strings"
	"unicode"
)

// Spec is the parsed form of an include spec. Specs can be constructed directly, or
// parsed from a terse string format using the Parse routine.
type Spec struct {
	// The name of the table that this is a spec for filling in
	TableName string
	// All the child tables to fill in
	Includes map[string]*Spec
}

func (s *Spec) String() string {
	var out strings.Builder

	seen := map[*Spec]bool{}
	s.writeToBuilder(&out, seen, false)

	return out.String()
}

var unquotedIdentRE = regexp.MustCompile("^[a-zA-Z_][a-zA-Z0-9_$]*$")

func (s *Spec) writeToBuilder(b *strings.Builder, seen map[*Spec]bool, stop bool) {
	if unquotedIdentRE.Match([]byte(s.TableName)) {
		b.WriteString(s.TableName)
	} else {
		quotedQuotes := strings.Replace(
			s.TableName, `"`, `""`, int(math.MinInt64))
		b.WriteByte('"')
		b.WriteString(quotedQuotes)
		b.WriteByte('"')
	}

	if stop {
		return
	}
	seen[s] = true

	if len(s.Includes) == 1 {
		b.WriteByte('.')
		for _, subSpec := range s.Includes {
			subSpec.writeToBuilder(b, seen, seen[subSpec])
		}
	} else if len(s.Includes) > 1 {
		b.WriteByte('.')

		// sort the sub-specs to ensure stable output
		subSpecs := make([]*Spec, len(s.Includes))[:0]
		for _, subSpec := range s.Includes {
			subSpecs = append(subSpecs, subSpec)
		}
		sort.Slice(subSpecs, func(i, j int) bool {
			return subSpecs[i].TableName < subSpecs[j].TableName
		})

		b.WriteByte('{')
		for i, subSpec := range subSpecs {
			subSpec.writeToBuilder(b, seen, seen[subSpec])
			if i < len(subSpecs)-1 {
				b.WriteByte(',')
			}
		}
		b.WriteByte('}')
	}
}

// Must can be used to turn an error from `include.Parse` into a panic
func Must(spec *Spec, err error) *Spec {
	if err != nil {
		panic(err)
	}
	return spec
}

// Parse an Spec from the given source string or an error on failure
func Parse(src string) (spec *Spec, err error) {
	var idx int
	spec, idx, err = parseSpec(src, 0)
	if err != nil {
		spec = nil
		return
	}

	// make sure there is no dangling input at the end
	idx = skipWS(src, idx)
	if idx < len(src) {
		err = &parseError{
			pos: idx,
			msg: fmt.Sprintf(
				"unexpected extra token begining with '%s'",
				string(src[idx]),
			),
		}
		spec = nil
		return
	}

	return
}

type parseError struct {
	pos int
	msg string
}

func (pe *parseError) Error() string {
	return fmt.Sprintf("at offset %d: %s", pe.pos, pe.msg)
}

func skipWS(src string, idx int) int {
	if idx >= len(src) {
		return idx
	}

	max := 0
	for i, r := range src[idx:] {
		if !unicode.IsSpace(r) {
			return idx + i
		}
		max = i
	}
	return idx + max + 1
}

func parseSpec(src string, idx int) (spec *Spec, nextIdx int, err error) {
	var s Spec

	idx = skipWS(src, idx)
	if idx >= len(src) {
		err = &parseError{
			pos: idx,
			msg: "expected an identifier to start a spec",
		}
		return
	}
	s.TableName, idx, err = parseID(src, idx)
	if err != nil {
		return
	}

	idx = skipWS(src, idx)
	if idx >= len(src) || src[idx] != '.' {
		// a bare identifier is a valid include spec
		spec = &s
		nextIdx = idx
		return
	}

	idx++
	idx = skipWS(src, idx)
	if idx >= len(src) {
		err = &parseError{
			pos: idx,
			msg: "expected spec or list of specs after '.'",
		}
		return
	}

	if src[idx] == '{' {
		// look for a list of sub specs
		var specList []*Spec
		specList, idx, err = parseSpecList(src, idx)
		if err != nil {
			return
		}

		s.Includes = map[string]*Spec{}
		for _, subSpec := range specList {
			s.Includes[subSpec.TableName] = subSpec
		}
	} else {
		// look for a solitary sub-spec not bracketed by curlies
		var subSpec *Spec
		subSpec, idx, err = parseSpec(src, idx)
		if err != nil {
			return
		}
		s.Includes = map[string]*Spec{subSpec.TableName: subSpec}
	}

	spec = &s
	nextIdx = idx
	return
}

func parseSpecList(src string, idx int) (specs []*Spec, nextIdx int, err error) {
	specs = []*Spec{}

	if src[idx] != '{' {
		err = &parseError{
			pos: idx,
			msg: "expected '{' to begin spec list",
		}
		return
	}

	unexpectedEOI := func(i int) error {
		return &parseError{
			pos: i,
			msg: "unexpected end of input while parsing spec list",
		}
	}

	idx++
	idx = skipWS(src, idx)
	if idx >= len(src) {
		err = unexpectedEOI(idx)
		return
	}

	// not needed, but produces a nicer error message
	if src[idx] == '}' {
		err = &parseError{
			pos: idx,
			msg: "empty spec list",
		}
		return
	}

	for {
		var subSpec *Spec
		subSpec, idx, err = parseSpec(src, idx)
		if err != nil {
			return
		}

		specs = append(specs, subSpec)

		idx = skipWS(src, idx)
		if idx >= len(src) {
			err = unexpectedEOI(idx)
			return
		}

		if src[idx] == '}' {
			idx++
			break
		}

		if src[idx] != ',' {
			err = &parseError{
				pos: idx,
				msg: "expected ',' to separate sub specs",
			}
			return
		}
		idx++
		idx = skipWS(src, idx)
		if idx >= len(src) {
			err = unexpectedEOI(idx)
			return
		}

		// allow trailing comma
		if src[idx] == '}' {
			idx++
			break
		}
	}

	nextIdx = idx
	return
}

// parse: [a-zA-Z_][a-zA-Z0-9_$]* | "[^"]"
func parseID(src string, idx int) (id string, nextIdx int, err error) {
	// first, we'll see if we are dealing with a quoted identifier
	if src[idx] == '"' {
		var idBuilder strings.Builder
		for {
			idx++
			if idx >= len(src) {
				err = &parseError{
					pos: idx,
					msg: "unexpected end of input in quoted identifier",
				}
				return
			}

			if src[idx] == '"' {
				if idx+1 < len(src) && src[idx+1] == '"' {
					idx++
					idBuilder.WriteByte('"')
				} else {
					id = idBuilder.String()
					nextIdx = idx + 1
					return
				}
			} else {
				idBuilder.WriteByte(src[idx])
			}
		}
	}

	// if it wasn't a quoted identifier we will fall through to looking
	// for a normal identifier

	seenFirst := false
	max := 0
	for i, r := range src[idx:] {
		stop := true
		if unicode.IsLetter(r) || r == '_' {
			stop = false
		}
		if seenFirst && (unicode.IsNumber(r) || r == '$') {
			stop = false
		}

		if stop {
			if i == 0 {
				err = &parseError{
					pos: idx,
					msg: fmt.Sprintf(
						"'%s' cannot begin an identifier",
						string(r),
					),
				}
			}

			id = src[idx : idx+i]
			nextIdx = idx + i
			return
		}

		max = i
		seenFirst = true
	}

	if max == 0 {
		return "", idx, &parseError{
			pos: idx,
			msg: "unexpected end of input when parsing an identifier",
		}
	} else {
		id = src[idx : idx+max+1]
		nextIdx = idx + max + 1
		return
	}
}
