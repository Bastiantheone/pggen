// package include defines include specs, which represent a subset of the
// object graph in the database. They can be used to instruct the code
// generated by pggen to load child entities attached to a given entity
// by a 1-1, 1-* or *-* relationship in an efficient way that avoids N+1 queries.
//
// In order to make defining include specs more convenient, they have a simple
// textual syntax for describing them. The syntax for include specs is reminiscent
// of dot access syntax, except that multiple tables can be accessed at once. For
// example, if you had an `foos` table that had a 1-* relationship with a `bars`
// table, you could use the following to produce an `include.Spec` to efficiently
// load all the bars attached to a foo:
//
// ```go
// spec := include.Must(include.Parse("foos.bars"))
// ```
//
// Dot access syntax works well enough when a table has just a single
// relationship, but it doesn't handle relationships with multiple tables,
// so include spec syntax allows you to write a list of sub-specs separated
// by commas and enclosed in a set of curly braces.
//
// For example, if the `foos` table also had a `bazes` attached to it with a 1-*
// relationship and the `bars` table had a `quxes` table attached to
// it in the same way, you could use to following to create a spec
// for loading all the objects attached to a given foo, even transitively.
//
// ```go
// spec := include.Must(include.Parse("foos.{bars.quxes, bazes}"))
// ```
//
// More formally, the grammar for include specs is:
//
// spec ::= id
//        | id '.' spec
//        | id '.' '{' spec_list '}'
// spec_list ::= spec
//             | spec ',' spec
//
package include

import (
	"fmt"
	"sort"
	"strings"
	"unicode"
)

// Spec is the parsed form of an include spec. Specs can be constructed directly, or
// parsed from a terse string format using the Parse routine.
type Spec struct {
	// The name of the table that this is a spec for filling in
	TableName string
	// All the child tables to fill in
	Includes map[string]*Spec
}

func (s *Spec) String() string {
	var out strings.Builder
	s.writeToBuilder(&out)
	return out.String()
}
func (s *Spec) writeToBuilder(b *strings.Builder) {
	b.WriteString(s.TableName)

	if len(s.Includes) == 1 {
		b.WriteByte('.')
		for _, subSpec := range s.Includes {
			subSpec.writeToBuilder(b)
		}
	} else if len(s.Includes) > 1 {
		b.WriteByte('.')

		// sort the sub-specs to ensure stable output
		subSpecs := make([]*Spec, len(s.Includes))[:0]
		for _, subSpec := range s.Includes {
			subSpecs = append(subSpecs, subSpec)
		}
		sort.Slice(subSpecs, func(i, j int) bool {
			return subSpecs[i].TableName < subSpecs[j].TableName
		})

		b.WriteByte('{')
		for i, subSpec := range subSpecs {
			subSpec.writeToBuilder(b)
			if i < len(subSpecs)-1 {
				b.WriteByte(',')
			}
		}
		b.WriteByte('}')
	}
}

// Must can be used to turn an error from `include.Parse` into a panic
func Must(spec *Spec, err error) *Spec {
	if err != nil {
		panic(err)
	}
	return spec
}

// Parse an Spec from the given source string or an error on failure
func Parse(src string) (spec *Spec, err error) {
	var idx int
	spec, idx, err = parseSpec(src, 0)
	if err != nil {
		spec = nil
		return
	}

	// make sure there is no dangling input at the end
	idx = skipWS(src, idx)
	if idx < len(src) {
		err = &parseError{
			pos: idx,
			msg: fmt.Sprintf(
				"unexpected extra token begining with '%s'",
				string(src[idx]),
			),
		}
		spec = nil
		return
	}

	return
}

type parseError struct {
	pos int
	msg string
}

func (pe *parseError) Error() string {
	return fmt.Sprintf("at offset %d: %s", pe.pos, pe.msg)
}

func skipWS(src string, idx int) int {
	if idx >= len(src) {
		return idx
	}

	max := 0
	for i, r := range src[idx:] {
		if !unicode.IsSpace(r) {
			return idx + i
		}
		max = i
	}
	return idx + max + 1
}

func parseSpec(src string, idx int) (spec *Spec, nextIdx int, err error) {
	var s Spec

	idx = skipWS(src, idx)
	if idx >= len(src) {
		err = &parseError{
			pos: idx,
			msg: "expected an identifier to start a spec",
		}
		return
	}
	s.TableName, idx, err = parseID(src, idx)
	if err != nil {
		return
	}

	idx = skipWS(src, idx)
	if idx >= len(src) || src[idx] != '.' {
		// a bare identifier is a valid include spec
		spec = &s
		nextIdx = idx
		return
	}

	idx++
	idx = skipWS(src, idx)
	if idx >= len(src) {
		err = &parseError{
			pos: idx,
			msg: "expected spec or list of specs after '.'",
		}
		return
	}

	if src[idx] == '{' {
		// look for a list of sub specs
		var specList []*Spec
		specList, idx, err = parseSpecList(src, idx)
		if err != nil {
			return
		}

		s.Includes = map[string]*Spec{}
		for _, subSpec := range specList {
			s.Includes[subSpec.TableName] = subSpec
		}
	} else {
		// look for a solitary sub-spec not bracketed by curlies
		var subSpec *Spec
		subSpec, idx, err = parseSpec(src, idx)
		if err != nil {
			return
		}
		s.Includes = map[string]*Spec{subSpec.TableName: subSpec}
	}

	spec = &s
	nextIdx = idx
	return
}

func parseSpecList(src string, idx int) (specs []*Spec, nextIdx int, err error) {
	specs = []*Spec{}

	if src[idx] != '{' {
		err = &parseError{
			pos: idx,
			msg: "expected '{' to begin spec list",
		}
		return
	}

	unexpectedEOI := func(i int) error {
		return &parseError{
			pos: i,
			msg: "unexpected end of input while parsing spec list",
		}
	}

	idx++
	idx = skipWS(src, idx)
	if idx >= len(src) {
		err = unexpectedEOI(idx)
		return
	}

	// not needed, but produces a nicer error message
	if src[idx] == '}' {
		err = &parseError{
			pos: idx,
			msg: "empty spec list",
		}
		return
	}

	for {
		var subSpec *Spec
		subSpec, idx, err = parseSpec(src, idx)
		if err != nil {
			return
		}

		specs = append(specs, subSpec)

		idx = skipWS(src, idx)
		if idx >= len(src) {
			err = unexpectedEOI(idx)
			return
		}

		if src[idx] == '}' {
			idx++
			break
		}

		if src[idx] != ',' {
			err = &parseError{
				pos: idx,
				msg: "expected ',' to separate sub specs",
			}
			return
		}
		idx++
		idx = skipWS(src, idx)
		if idx >= len(src) {
			err = unexpectedEOI(idx)
			return
		}

		// allow trailing comma
		if src[idx] == '}' {
			idx++
			break
		}
	}

	nextIdx = idx
	return
}

// parse [a-zA-Z_][a-zA-Z0-9_]*
func parseID(src string, idx int) (id string, nextIdx int, err error) {
	seenFirst := false
	max := 0
	for i, r := range src[idx:] {
		stop := true
		if unicode.IsLetter(r) || r == '_' {
			stop = false
		}
		if seenFirst && unicode.IsNumber(r) {
			stop = false
		}

		if stop {
			if i == 0 {
				err = &parseError{
					pos: idx,
					msg: fmt.Sprintf(
						"'%s' cannot begin an identifier",
						string(r),
					),
				}
			}

			id = src[idx : idx+i]
			nextIdx = idx + i
			return
		}

		max = i
		seenFirst = true
	}

	if max == 0 {
		return "", idx, &parseError{
			pos: idx,
			msg: "unexpected end of input when parsing an identifier",
		}
	} else {
		id = src[idx : idx+max+1]
		nextIdx = idx + max + 1
		return
	}
}
