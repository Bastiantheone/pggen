// Code generated by pggen DO NOT EDIT

package models

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/lib/pq"
	"github.com/opendoor-labs/pggen"
	"github.com/opendoor-labs/pggen/include"
	"strings"
)

// PGClient wraps either a 'sql.DB' or a 'sql.Tx'. All pggen-generated
// database access methods for this package are attached to it.
type PGClient struct {
	impl       pgClientImpl
	topLevelDB *sql.DB

	// These column indexes are used at run time to enable us to 'SELECT *' against
	// a table that has the same columns in a different order from the ones that we
	// saw in the table we used to generate code. This means that you don't have to worry
	// about migrations merging in a slightly different order than their timestamps have
	// breaking 'SELECT *'.
	colIdxTabForFoo []int
}

func NewPGClient(conn *sql.DB) *PGClient {
	client := PGClient{
		topLevelDB: conn,
	}
	client.impl = pgClientImpl{
		db:     conn,
		client: &client,
	}

	return &client
}

func (p *PGClient) Handle() pggen.DBHandle {
	return p.topLevelDB
}

func (p *PGClient) BeginTx(ctx context.Context, opts *sql.TxOptions) (*TxPGClient, error) {
	tx, err := p.topLevelDB.BeginTx(ctx, opts)
	if err != nil {
		return nil, err
	}

	return &TxPGClient{
		impl: pgClientImpl{
			db:     tx,
			client: p,
		},
	}, nil
}

// A postgres client that operates within a transaction. Supports all the same
// generated methods that PGClient does.
type TxPGClient struct {
	impl pgClientImpl
}

func (tx *TxPGClient) Handle() pggen.DBHandle {
	return tx.impl.db.(*sql.Tx)
}

func (tx *TxPGClient) Rollback() error {
	return tx.impl.db.(*sql.Tx).Rollback()
}

func (tx *TxPGClient) Commit() error {
	return tx.impl.db.(*sql.Tx).Commit()
}

// A database client that can wrap either a direct database connection or a transaction
type pgClientImpl struct {
	db pggen.DBHandle
	// a reference back to the owning PGClient so we can always get at the resolver tables
	client *PGClient
}

func (p *PGClient) GetFoo(
	ctx context.Context,
	id int64,
) (*Foo, error) {
	return p.impl.GetFoo(ctx, id)
}
func (tx *TxPGClient) GetFoo(
	ctx context.Context,
	id int64,
) (*Foo, error) {
	return tx.impl.GetFoo(ctx, id)
}
func (p *pgClientImpl) GetFoo(
	ctx context.Context,
	id int64,
) (*Foo, error) {
	values, err := p.ListFoo(ctx, []int64{id})
	if err != nil {
		return nil, err
	}

	// ListFoo always returns the same number of records as were
	// requested, so this is safe.
	return &values[0], err
}

func (p *PGClient) ListFoo(
	ctx context.Context,
	ids []int64,
) (ret []Foo, err error) {
	return p.impl.ListFoo(ctx, ids)
}
func (tx *TxPGClient) ListFoo(
	ctx context.Context,
	ids []int64,
) (ret []Foo, err error) {
	return tx.impl.ListFoo(ctx, ids)
}
func (p *pgClientImpl) ListFoo(
	ctx context.Context,
	ids []int64,
) (ret []Foo, err error) {
	if len(ids) == 0 {
		return []Foo{}, nil
	}

	rows, err := p.db.QueryContext(
		ctx,
		"SELECT * FROM \"foos\" WHERE \"id\" = ANY($1)",
		pq.Array(ids),
	)
	if err != nil {
		return nil, err
	}
	defer func() {
		if err == nil {
			err = rows.Close()
			if err != nil {
				ret = nil
			}
		} else {
			rowErr := rows.Close()
			if rowErr != nil {
				err = fmt.Errorf("%s AND %s", err.Error(), rowErr.Error())
			}
		}
	}()

	ret = make([]Foo, 0, len(ids))
	for rows.Next() {
		var value Foo
		err = value.Scan(ctx, p.client, rows)
		if err != nil {
			return nil, err
		}
		ret = append(ret, value)
	}

	if len(ret) != len(ids) {
		return nil, fmt.Errorf(
			"ListFoo: asked for %d records, found %d",
			len(ids),
			len(ret),
		)
	}

	return ret, nil
}

// Insert a Foo into the database. Returns the primary
// key of the inserted row.
func (p *PGClient) InsertFoo(
	ctx context.Context,
	value *Foo,
	opts ...pggen.InsertOpt,
) (ret int64, err error) {
	return p.impl.InsertFoo(ctx, value, opts...)
}

// Insert a Foo into the database. Returns the primary
// key of the inserted row.
func (tx *TxPGClient) InsertFoo(
	ctx context.Context,
	value *Foo,
	opts ...pggen.InsertOpt,
) (ret int64, err error) {
	return tx.impl.InsertFoo(ctx, value, opts...)
}

// Insert a Foo into the database. Returns the primary
// key of the inserted row.
func (p *pgClientImpl) InsertFoo(
	ctx context.Context,
	value *Foo,
	opts ...pggen.InsertOpt,
) (ret int64, err error) {
	var ids []int64
	ids, err = p.BulkInsertFoo(ctx, []Foo{*value}, opts...)
	if err != nil {
		return
	}

	if len(ids) != 1 {
		err = fmt.Errorf("inserting a Foo: %d ids (expected 1)", len(ids))
		return
	}

	ret = ids[0]
	return
}

// Insert a list of Foo. Returns a list of the primary keys of
// the inserted rows.
func (p *PGClient) BulkInsertFoo(
	ctx context.Context,
	values []Foo,
	opts ...pggen.InsertOpt,
) ([]int64, error) {
	return p.impl.BulkInsertFoo(ctx, values, opts...)
}

// Insert a list of Foo. Returns a list of the primary keys of
// the inserted rows.
func (tx *TxPGClient) BulkInsertFoo(
	ctx context.Context,
	values []Foo,
	opts ...pggen.InsertOpt,
) ([]int64, error) {
	return tx.impl.BulkInsertFoo(ctx, values, opts...)
}

// Insert a list of Foo. Returns a list of the primary keys of
// the inserted rows.
func (p *pgClientImpl) BulkInsertFoo(
	ctx context.Context,
	values []Foo,
	opts ...pggen.InsertOpt,
) ([]int64, error) {
	if len(values) == 0 {
		return []int64{}, nil
	}

	opt := pggen.InsertOptions{}
	for _, o := range opts {
		o(&opt)
	}

	args := make([]interface{}, 0, 2*len(values))
	for _, v := range values {
		if opt.UsePkey {
			args = append(args, v.Id)
		}
		args = append(args, v.Value)
	}

	bulkInsertQuery := genBulkInsertStmt(
		"foos",
		fieldsForFoo,
		len(values),
		"id",
		opt.UsePkey,
	)

	rows, err := p.db.QueryContext(ctx, bulkInsertQuery, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	ids := make([]int64, 0, len(values))
	for rows.Next() {
		var id int64
		err = rows.Scan(&(id))
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}

	return ids, nil
}

// bit indicies for 'fieldMask' parameters
const (
	FooIdFieldIndex    int = 0
	FooValueFieldIndex int = 1
	FooMaxFieldIndex   int = (2 - 1)
)

// A field set saying that all fields in Foo should be updated.
// For use as a 'fieldMask' parameter
var FooAllFields pggen.FieldSet = pggen.NewFieldSetFilled(2)

var fieldsForFoo []string = []string{
	`id`,
	`value`,
}

// Update a Foo. 'value' must at the least have
// a primary key set. The 'fieldMask' field set indicates which fields
// should be updated in the database.
//
// Returns the primary key of the updated row.
func (p *PGClient) UpdateFoo(
	ctx context.Context,
	value *Foo,
	fieldMask pggen.FieldSet,
) (ret int64, err error) {
	return p.impl.UpdateFoo(ctx, value, fieldMask)
}

// Update a Foo. 'value' must at the least have
// a primary key set. The 'fieldMask' field set indicates which fields
// should be updated in the database.
//
// Returns the primary key of the updated row.
func (tx *TxPGClient) UpdateFoo(
	ctx context.Context,
	value *Foo,
	fieldMask pggen.FieldSet,
) (ret int64, err error) {
	return tx.impl.UpdateFoo(ctx, value, fieldMask)
}
func (p *pgClientImpl) UpdateFoo(
	ctx context.Context,
	value *Foo,
	fieldMask pggen.FieldSet,
) (ret int64, err error) {
	if !fieldMask.Test(FooIdFieldIndex) {
		err = fmt.Errorf("primary key required for updates to 'foos'")
		return
	}

	updateStmt := genUpdateStmt(
		"foos",
		"id",
		fieldsForFoo,
		fieldMask,
		"id",
	)

	args := make([]interface{}, 0, 2)
	if fieldMask.Test(FooIdFieldIndex) {
		args = append(args, value.Id)
	}
	if fieldMask.Test(FooValueFieldIndex) {
		args = append(args, value.Value)
	}

	// add the primary key arg for the WHERE condition
	args = append(args, value.Id)

	var id int64
	err = p.db.QueryRowContext(ctx, updateStmt, args...).
		Scan(&(id))
	if err != nil {
		return
	}

	return id, nil
}

// Updsert a Foo value. If the given value conflicts with
// an existing row in the database, use the provided value to update that row
// rather than inserting it. Only the fields specified by 'fieldMask' are
// actually updated. All other fields are left as-is.
func (p *PGClient) UpsertFoo(
	ctx context.Context,
	value *Foo,
	constraintNames []string,
	fieldMask pggen.FieldSet,
) (ret int64, err error) {
	var val []int64
	val, err = p.impl.BulkUpsertFoo(ctx, []Foo{*value}, constraintNames, fieldMask)
	if err != nil {
		return
	}
	if len(val) == 1 {
		return val[0], nil
	}

	// only possible if no upsert fields were specified by the field mask
	return value.Id, nil
}

// Updsert a Foo value. If the given value conflicts with
// an existing row in the database, use the provided value to update that row
// rather than inserting it. Only the fields specified by 'fieldMask' are
// actually updated. All other fields are left as-is.
func (tx *TxPGClient) UpsertFoo(
	ctx context.Context,
	value *Foo,
	constraintNames []string,
	fieldMask pggen.FieldSet,
) (ret int64, err error) {
	var val []int64
	val, err = tx.impl.BulkUpsertFoo(ctx, []Foo{*value}, constraintNames, fieldMask)
	if err != nil {
		return
	}
	if len(val) == 1 {
		return val[0], nil
	}

	// only possible if no upsert fields were specified by the field mask
	return value.Id, nil
}

// Updsert a set of Foo values. If any of the given values conflict with
// existing rows in the database, use the provided values to update the rows which
// exist in the database rather than inserting them. Only the fields specified by
// 'fieldMask' are actually updated. All other fields are left as-is.
func (p *PGClient) BulkUpsertFoo(
	ctx context.Context,
	values []Foo,
	constraintNames []string,
	fieldMask pggen.FieldSet,
) (ret []int64, err error) {
	return p.impl.BulkUpsertFoo(ctx, values, constraintNames, fieldMask)
}

// Updsert a set of Foo values. If any of the given values conflict with
// existing rows in the database, use the provided values to update the rows which
// exist in the database rather than inserting them. Only the fields specified by
// 'fieldMask' are actually updated. All other fields are left as-is.
func (tx *TxPGClient) BulkUpsertFoo(
	ctx context.Context,
	values []Foo,
	constraintNames []string,
	fieldMask pggen.FieldSet,
) (ret []int64, err error) {
	return tx.impl.BulkUpsertFoo(ctx, values, constraintNames, fieldMask)
}
func (p *pgClientImpl) BulkUpsertFoo(
	ctx context.Context,
	values []Foo,
	constraintNames []string,
	fieldMask pggen.FieldSet,
) ([]int64, error) {
	if len(values) == 0 {
		return []int64{}, nil
	}

	if constraintNames == nil || len(constraintNames) == 0 {
		constraintNames = []string{`id`}
	}

	var stmt strings.Builder
	genInsertCommon(
		&stmt,
		`foos`,
		fieldsForFoo,
		len(values),
		`id`,
		fieldMask.Test(FooIdFieldIndex),
	)

	if fieldMask.CountSetBits() > 0 {
		stmt.WriteString("ON CONFLICT (")
		stmt.WriteString(strings.Join(constraintNames, ","))
		stmt.WriteString(") DO UPDATE SET ")

		updateCols := make([]string, 0, 2)
		updateExprs := make([]string, 0, 2)
		if fieldMask.Test(FooIdFieldIndex) {
			updateCols = append(updateCols, `id`)
			updateExprs = append(updateExprs, `excluded.id`)
		}
		if fieldMask.Test(FooValueFieldIndex) {
			updateCols = append(updateCols, `value`)
			updateExprs = append(updateExprs, `excluded.value`)
		}
		if len(updateCols) > 1 {
			stmt.WriteRune('(')
		}
		stmt.WriteString(strings.Join(updateCols, ","))
		if len(updateCols) > 1 {
			stmt.WriteRune(')')
		}
		stmt.WriteString(" = ")
		if len(updateCols) > 1 {
			stmt.WriteRune('(')
		}
		stmt.WriteString(strings.Join(updateExprs, ","))
		if len(updateCols) > 1 {
			stmt.WriteRune(')')
		}
	} else {
		stmt.WriteString("ON CONFLICT DO NOTHING")
	}

	stmt.WriteString(` RETURNING "id"`)

	args := make([]interface{}, 0, 2*len(values))
	for _, v := range values {
		if fieldMask.Test(FooIdFieldIndex) {
			args = append(args, v.Id)
		}
		args = append(args, v.Value)
	}

	rows, err := p.db.QueryContext(ctx, stmt.String(), args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	ids := make([]int64, 0, len(values))
	for rows.Next() {
		var id int64
		err = rows.Scan(&(id))
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}

	return ids, nil
}

func (p *PGClient) DeleteFoo(
	ctx context.Context,
	id int64,
) error {
	return p.impl.BulkDeleteFoo(ctx, []int64{id})
}
func (tx *TxPGClient) DeleteFoo(
	ctx context.Context,
	id int64,
) error {
	return tx.impl.BulkDeleteFoo(ctx, []int64{id})
}

func (p *PGClient) BulkDeleteFoo(
	ctx context.Context,
	ids []int64,
) error {
	return p.impl.BulkDeleteFoo(ctx, ids)
}
func (tx *TxPGClient) BulkDeleteFoo(
	ctx context.Context,
	ids []int64,
) error {
	return tx.impl.BulkDeleteFoo(ctx, ids)
}
func (p *pgClientImpl) BulkDeleteFoo(
	ctx context.Context,
	ids []int64,
) error {
	if len(ids) == 0 {
		return nil
	}

	res, err := p.db.ExecContext(
		ctx,
		"DELETE FROM \"foos\" WHERE \"id\" = ANY($1)",
		pq.Array(ids),
	)
	if err != nil {
		return err
	}

	nrows, err := res.RowsAffected()
	if err != nil {
		return err
	}

	if nrows != int64(len(ids)) {
		return fmt.Errorf(
			"BulkDeleteFoo: %d rows deleted, expected %d",
			nrows,
			len(ids),
		)
	}

	return err
}

var FooAllIncludes *include.Spec = include.Must(include.Parse(
	`foos`,
))

func (p *PGClient) FooFillIncludes(
	ctx context.Context,
	rec *Foo,
	includes *include.Spec,
) error {
	return p.impl.FooBulkFillIncludes(ctx, []*Foo{rec}, includes)
}
func (tx *TxPGClient) FooFillIncludes(
	ctx context.Context,
	rec *Foo,
	includes *include.Spec,
) error {
	return tx.impl.FooBulkFillIncludes(ctx, []*Foo{rec}, includes)
}

func (p *PGClient) FooBulkFillIncludes(
	ctx context.Context,
	recs []*Foo,
	includes *include.Spec,
) error {
	return p.impl.FooBulkFillIncludes(ctx, recs, includes)
}
func (tx *TxPGClient) FooBulkFillIncludes(
	ctx context.Context,
	recs []*Foo,
	includes *include.Spec,
) error {
	return tx.impl.FooBulkFillIncludes(ctx, recs, includes)
}
func (p *pgClientImpl) FooBulkFillIncludes(
	ctx context.Context,
	recs []*Foo,
	includes *include.Spec,
) error {
	loadedRecordTab := map[string]interface{}{}

	return p.implFooBulkFillIncludes(ctx, recs, includes, loadedRecordTab)
}

func (p *pgClientImpl) implFooBulkFillIncludes(
	ctx context.Context,
	recs []*Foo,
	includes *include.Spec,
	loadedRecordTab map[string]interface{},
) (err error) {
	if includes.TableName != "foos" {
		return fmt.Errorf(
			"expected includes for 'foos', got '%s'",
			includes.TableName,
		)
	}

	loadedTab, inMap := loadedRecordTab[`foos`]
	if inMap {
		idToRecord := loadedTab.(map[int64]*Foo)
		for _, r := range recs {
			_, alreadyLoaded := idToRecord[r.Id]
			if !alreadyLoaded {
				idToRecord[r.Id] = r
			}
		}
	} else {
		idToRecord := make(map[int64]*Foo, len(recs))
		for _, r := range recs {
			idToRecord[r.Id] = r
		}
		loadedRecordTab[`foos`] = idToRecord
	}

	return
}

func (p *PGClient) GetFooValues(
	ctx context.Context,
	arg0 []int64,
) (ret []*string, err error) {
	return p.impl.GetFooValues(
		ctx,
		arg0,
	)
}
func (tx *TxPGClient) GetFooValues(
	ctx context.Context,
	arg0 []int64,
) (ret []*string, err error) {
	return tx.impl.GetFooValues(
		ctx,
		arg0,
	)
}
func (p *pgClientImpl) GetFooValues(
	ctx context.Context,
	arg0 []int64,
) (ret []*string, err error) {
	ret = []*string{}

	var rows *sql.Rows
	rows, err = p.GetFooValuesQuery(
		ctx,
		arg0,
	)
	if err != nil {
		return nil, err
	}
	defer func() {
		if err == nil {
			err = rows.Close()
			if err != nil {
				ret = nil
			}
		} else {
			rowErr := rows.Close()
			if rowErr != nil {
				err = fmt.Errorf("%s AND %s", err.Error(), rowErr.Error())
			}
		}
	}()

	for rows.Next() {
		var row *string
		var scanTgt sql.NullString
		err = rows.Scan(&(scanTgt))
		if err != nil {
			return nil, err
		}
		row = convertNullString(scanTgt)
		ret = append(ret, row)
	}

	return
}

func (p *PGClient) GetFooValuesQuery(
	ctx context.Context,
	arg0 []int64,
) (*sql.Rows, error) {
	return p.impl.GetFooValuesQuery(
		ctx,
		arg0,
	)
}
func (tx *TxPGClient) GetFooValuesQuery(
	ctx context.Context,
	arg0 []int64,
) (*sql.Rows, error) {
	return tx.impl.GetFooValuesQuery(
		ctx,
		arg0,
	)
}
func (p *pgClientImpl) GetFooValuesQuery(
	ctx context.Context,
	arg0 []int64,
) (*sql.Rows, error) {
	return p.db.QueryContext(
		ctx,
		`SELECT value FROM foos WHERE id = ANY($1)`,
		pq.Array(arg0),
	)
}

type Foo struct {
	Id    int64   `gorm:"column:id" gorm:"is_primary"`
	Value *string `gorm:"column:value"`
}

func (r *Foo) Scan(ctx context.Context, client *PGClient, rs *sql.Rows) error {
	if client.colIdxTabForFoo == nil {
		err := client.fillColPosTab(
			ctx,
			genTimeColIdxTabForFoo,
			`foos`,
			&client.colIdxTabForFoo,
		)
		if err != nil {
			return err
		}
	}

	var nullableTgts nullableScanTgtsForFoo

	scanTgts := make([]interface{}, len(client.colIdxTabForFoo))
	for runIdx, genIdx := range client.colIdxTabForFoo {
		if genIdx == -1 {
			scanTgts[runIdx] = &pggenSinkScanner{}
		} else {
			scanTgts[runIdx] = scannerTabForFoo[genIdx](r, &nullableTgts)
		}
	}

	err := rs.Scan(scanTgts...)
	if err != nil {
		return err
	}
	r.Value = convertNullString(nullableTgts.scanValue)

	return nil
}

type nullableScanTgtsForFoo struct {
	scanValue sql.NullString
}

// a table mapping codegen-time col indicies to functions returning a scanner for the
// field that was at that column index at codegen-time.
var scannerTabForFoo = [...]func(*Foo, *nullableScanTgtsForFoo) interface{}{
	func(
		r *Foo,
		nullableTgts *nullableScanTgtsForFoo,
	) interface{} {
		return &(r.Id)
	},
	func(
		r *Foo,
		nullableTgts *nullableScanTgtsForFoo,
	) interface{} {
		return &(nullableTgts.scanValue)
	},
}

var genTimeColIdxTabForFoo map[string]int = map[string]int{
	`id`:    0,
	`value`: 1,
}
