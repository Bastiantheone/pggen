// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"database/sql"
	"database/sql/driver"
	"sync"
	"time"

	"github.com/opendoor-labs/pggen"
)

type DBConn struct {
	BeginTxStub        func(context.Context, *sql.TxOptions) (*sql.Tx, error)
	beginTxMutex       sync.RWMutex
	beginTxArgsForCall []struct {
		arg1 context.Context
		arg2 *sql.TxOptions
	}
	beginTxReturns struct {
		result1 *sql.Tx
		result2 error
	}
	beginTxReturnsOnCall map[int]struct {
		result1 *sql.Tx
		result2 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	ConnStub        func(context.Context) (*sql.Conn, error)
	connMutex       sync.RWMutex
	connArgsForCall []struct {
		arg1 context.Context
	}
	connReturns struct {
		result1 *sql.Conn
		result2 error
	}
	connReturnsOnCall map[int]struct {
		result1 *sql.Conn
		result2 error
	}
	DriverStub        func() driver.Driver
	driverMutex       sync.RWMutex
	driverArgsForCall []struct {
	}
	driverReturns struct {
		result1 driver.Driver
	}
	driverReturnsOnCall map[int]struct {
		result1 driver.Driver
	}
	ExecContextStub        func(context.Context, string, ...interface{}) (sql.Result, error)
	execContextMutex       sync.RWMutex
	execContextArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	execContextReturns struct {
		result1 sql.Result
		result2 error
	}
	execContextReturnsOnCall map[int]struct {
		result1 sql.Result
		result2 error
	}
	PingContextStub        func(context.Context) error
	pingContextMutex       sync.RWMutex
	pingContextArgsForCall []struct {
		arg1 context.Context
	}
	pingContextReturns struct {
		result1 error
	}
	pingContextReturnsOnCall map[int]struct {
		result1 error
	}
	PrepareContextStub        func(context.Context, string) (*sql.Stmt, error)
	prepareContextMutex       sync.RWMutex
	prepareContextArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	prepareContextReturns struct {
		result1 *sql.Stmt
		result2 error
	}
	prepareContextReturnsOnCall map[int]struct {
		result1 *sql.Stmt
		result2 error
	}
	QueryContextStub        func(context.Context, string, ...interface{}) (*sql.Rows, error)
	queryContextMutex       sync.RWMutex
	queryContextArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	queryContextReturns struct {
		result1 *sql.Rows
		result2 error
	}
	queryContextReturnsOnCall map[int]struct {
		result1 *sql.Rows
		result2 error
	}
	QueryRowContextStub        func(context.Context, string, ...interface{}) *sql.Row
	queryRowContextMutex       sync.RWMutex
	queryRowContextArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	queryRowContextReturns struct {
		result1 *sql.Row
	}
	queryRowContextReturnsOnCall map[int]struct {
		result1 *sql.Row
	}
	SetConnMaxLifetimeStub        func(time.Duration)
	setConnMaxLifetimeMutex       sync.RWMutex
	setConnMaxLifetimeArgsForCall []struct {
		arg1 time.Duration
	}
	SetMaxIdleConnsStub        func(int)
	setMaxIdleConnsMutex       sync.RWMutex
	setMaxIdleConnsArgsForCall []struct {
		arg1 int
	}
	SetMaxOpenConnsStub        func(int)
	setMaxOpenConnsMutex       sync.RWMutex
	setMaxOpenConnsArgsForCall []struct {
		arg1 int
	}
	StatsStub        func() sql.DBStats
	statsMutex       sync.RWMutex
	statsArgsForCall []struct {
	}
	statsReturns struct {
		result1 sql.DBStats
	}
	statsReturnsOnCall map[int]struct {
		result1 sql.DBStats
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *DBConn) BeginTx(arg1 context.Context, arg2 *sql.TxOptions) (*sql.Tx, error) {
	fake.beginTxMutex.Lock()
	ret, specificReturn := fake.beginTxReturnsOnCall[len(fake.beginTxArgsForCall)]
	fake.beginTxArgsForCall = append(fake.beginTxArgsForCall, struct {
		arg1 context.Context
		arg2 *sql.TxOptions
	}{arg1, arg2})
	fake.recordInvocation("BeginTx", []interface{}{arg1, arg2})
	fake.beginTxMutex.Unlock()
	if fake.BeginTxStub != nil {
		return fake.BeginTxStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.beginTxReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *DBConn) BeginTxCallCount() int {
	fake.beginTxMutex.RLock()
	defer fake.beginTxMutex.RUnlock()
	return len(fake.beginTxArgsForCall)
}

func (fake *DBConn) BeginTxCalls(stub func(context.Context, *sql.TxOptions) (*sql.Tx, error)) {
	fake.beginTxMutex.Lock()
	defer fake.beginTxMutex.Unlock()
	fake.BeginTxStub = stub
}

func (fake *DBConn) BeginTxArgsForCall(i int) (context.Context, *sql.TxOptions) {
	fake.beginTxMutex.RLock()
	defer fake.beginTxMutex.RUnlock()
	argsForCall := fake.beginTxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *DBConn) BeginTxReturns(result1 *sql.Tx, result2 error) {
	fake.beginTxMutex.Lock()
	defer fake.beginTxMutex.Unlock()
	fake.BeginTxStub = nil
	fake.beginTxReturns = struct {
		result1 *sql.Tx
		result2 error
	}{result1, result2}
}

func (fake *DBConn) BeginTxReturnsOnCall(i int, result1 *sql.Tx, result2 error) {
	fake.beginTxMutex.Lock()
	defer fake.beginTxMutex.Unlock()
	fake.BeginTxStub = nil
	if fake.beginTxReturnsOnCall == nil {
		fake.beginTxReturnsOnCall = make(map[int]struct {
			result1 *sql.Tx
			result2 error
		})
	}
	fake.beginTxReturnsOnCall[i] = struct {
		result1 *sql.Tx
		result2 error
	}{result1, result2}
}

func (fake *DBConn) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.closeReturns
	return fakeReturns.result1
}

func (fake *DBConn) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *DBConn) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *DBConn) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *DBConn) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *DBConn) Conn(arg1 context.Context) (*sql.Conn, error) {
	fake.connMutex.Lock()
	ret, specificReturn := fake.connReturnsOnCall[len(fake.connArgsForCall)]
	fake.connArgsForCall = append(fake.connArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Conn", []interface{}{arg1})
	fake.connMutex.Unlock()
	if fake.ConnStub != nil {
		return fake.ConnStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.connReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *DBConn) ConnCallCount() int {
	fake.connMutex.RLock()
	defer fake.connMutex.RUnlock()
	return len(fake.connArgsForCall)
}

func (fake *DBConn) ConnCalls(stub func(context.Context) (*sql.Conn, error)) {
	fake.connMutex.Lock()
	defer fake.connMutex.Unlock()
	fake.ConnStub = stub
}

func (fake *DBConn) ConnArgsForCall(i int) context.Context {
	fake.connMutex.RLock()
	defer fake.connMutex.RUnlock()
	argsForCall := fake.connArgsForCall[i]
	return argsForCall.arg1
}

func (fake *DBConn) ConnReturns(result1 *sql.Conn, result2 error) {
	fake.connMutex.Lock()
	defer fake.connMutex.Unlock()
	fake.ConnStub = nil
	fake.connReturns = struct {
		result1 *sql.Conn
		result2 error
	}{result1, result2}
}

func (fake *DBConn) ConnReturnsOnCall(i int, result1 *sql.Conn, result2 error) {
	fake.connMutex.Lock()
	defer fake.connMutex.Unlock()
	fake.ConnStub = nil
	if fake.connReturnsOnCall == nil {
		fake.connReturnsOnCall = make(map[int]struct {
			result1 *sql.Conn
			result2 error
		})
	}
	fake.connReturnsOnCall[i] = struct {
		result1 *sql.Conn
		result2 error
	}{result1, result2}
}

func (fake *DBConn) Driver() driver.Driver {
	fake.driverMutex.Lock()
	ret, specificReturn := fake.driverReturnsOnCall[len(fake.driverArgsForCall)]
	fake.driverArgsForCall = append(fake.driverArgsForCall, struct {
	}{})
	fake.recordInvocation("Driver", []interface{}{})
	fake.driverMutex.Unlock()
	if fake.DriverStub != nil {
		return fake.DriverStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.driverReturns
	return fakeReturns.result1
}

func (fake *DBConn) DriverCallCount() int {
	fake.driverMutex.RLock()
	defer fake.driverMutex.RUnlock()
	return len(fake.driverArgsForCall)
}

func (fake *DBConn) DriverCalls(stub func() driver.Driver) {
	fake.driverMutex.Lock()
	defer fake.driverMutex.Unlock()
	fake.DriverStub = stub
}

func (fake *DBConn) DriverReturns(result1 driver.Driver) {
	fake.driverMutex.Lock()
	defer fake.driverMutex.Unlock()
	fake.DriverStub = nil
	fake.driverReturns = struct {
		result1 driver.Driver
	}{result1}
}

func (fake *DBConn) DriverReturnsOnCall(i int, result1 driver.Driver) {
	fake.driverMutex.Lock()
	defer fake.driverMutex.Unlock()
	fake.DriverStub = nil
	if fake.driverReturnsOnCall == nil {
		fake.driverReturnsOnCall = make(map[int]struct {
			result1 driver.Driver
		})
	}
	fake.driverReturnsOnCall[i] = struct {
		result1 driver.Driver
	}{result1}
}

func (fake *DBConn) ExecContext(arg1 context.Context, arg2 string, arg3 ...interface{}) (sql.Result, error) {
	fake.execContextMutex.Lock()
	ret, specificReturn := fake.execContextReturnsOnCall[len(fake.execContextArgsForCall)]
	fake.execContextArgsForCall = append(fake.execContextArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("ExecContext", []interface{}{arg1, arg2, arg3})
	fake.execContextMutex.Unlock()
	if fake.ExecContextStub != nil {
		return fake.ExecContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.execContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *DBConn) ExecContextCallCount() int {
	fake.execContextMutex.RLock()
	defer fake.execContextMutex.RUnlock()
	return len(fake.execContextArgsForCall)
}

func (fake *DBConn) ExecContextCalls(stub func(context.Context, string, ...interface{}) (sql.Result, error)) {
	fake.execContextMutex.Lock()
	defer fake.execContextMutex.Unlock()
	fake.ExecContextStub = stub
}

func (fake *DBConn) ExecContextArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.execContextMutex.RLock()
	defer fake.execContextMutex.RUnlock()
	argsForCall := fake.execContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *DBConn) ExecContextReturns(result1 sql.Result, result2 error) {
	fake.execContextMutex.Lock()
	defer fake.execContextMutex.Unlock()
	fake.ExecContextStub = nil
	fake.execContextReturns = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *DBConn) ExecContextReturnsOnCall(i int, result1 sql.Result, result2 error) {
	fake.execContextMutex.Lock()
	defer fake.execContextMutex.Unlock()
	fake.ExecContextStub = nil
	if fake.execContextReturnsOnCall == nil {
		fake.execContextReturnsOnCall = make(map[int]struct {
			result1 sql.Result
			result2 error
		})
	}
	fake.execContextReturnsOnCall[i] = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *DBConn) PingContext(arg1 context.Context) error {
	fake.pingContextMutex.Lock()
	ret, specificReturn := fake.pingContextReturnsOnCall[len(fake.pingContextArgsForCall)]
	fake.pingContextArgsForCall = append(fake.pingContextArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("PingContext", []interface{}{arg1})
	fake.pingContextMutex.Unlock()
	if fake.PingContextStub != nil {
		return fake.PingContextStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pingContextReturns
	return fakeReturns.result1
}

func (fake *DBConn) PingContextCallCount() int {
	fake.pingContextMutex.RLock()
	defer fake.pingContextMutex.RUnlock()
	return len(fake.pingContextArgsForCall)
}

func (fake *DBConn) PingContextCalls(stub func(context.Context) error) {
	fake.pingContextMutex.Lock()
	defer fake.pingContextMutex.Unlock()
	fake.PingContextStub = stub
}

func (fake *DBConn) PingContextArgsForCall(i int) context.Context {
	fake.pingContextMutex.RLock()
	defer fake.pingContextMutex.RUnlock()
	argsForCall := fake.pingContextArgsForCall[i]
	return argsForCall.arg1
}

func (fake *DBConn) PingContextReturns(result1 error) {
	fake.pingContextMutex.Lock()
	defer fake.pingContextMutex.Unlock()
	fake.PingContextStub = nil
	fake.pingContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *DBConn) PingContextReturnsOnCall(i int, result1 error) {
	fake.pingContextMutex.Lock()
	defer fake.pingContextMutex.Unlock()
	fake.PingContextStub = nil
	if fake.pingContextReturnsOnCall == nil {
		fake.pingContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pingContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *DBConn) PrepareContext(arg1 context.Context, arg2 string) (*sql.Stmt, error) {
	fake.prepareContextMutex.Lock()
	ret, specificReturn := fake.prepareContextReturnsOnCall[len(fake.prepareContextArgsForCall)]
	fake.prepareContextArgsForCall = append(fake.prepareContextArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("PrepareContext", []interface{}{arg1, arg2})
	fake.prepareContextMutex.Unlock()
	if fake.PrepareContextStub != nil {
		return fake.PrepareContextStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.prepareContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *DBConn) PrepareContextCallCount() int {
	fake.prepareContextMutex.RLock()
	defer fake.prepareContextMutex.RUnlock()
	return len(fake.prepareContextArgsForCall)
}

func (fake *DBConn) PrepareContextCalls(stub func(context.Context, string) (*sql.Stmt, error)) {
	fake.prepareContextMutex.Lock()
	defer fake.prepareContextMutex.Unlock()
	fake.PrepareContextStub = stub
}

func (fake *DBConn) PrepareContextArgsForCall(i int) (context.Context, string) {
	fake.prepareContextMutex.RLock()
	defer fake.prepareContextMutex.RUnlock()
	argsForCall := fake.prepareContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *DBConn) PrepareContextReturns(result1 *sql.Stmt, result2 error) {
	fake.prepareContextMutex.Lock()
	defer fake.prepareContextMutex.Unlock()
	fake.PrepareContextStub = nil
	fake.prepareContextReturns = struct {
		result1 *sql.Stmt
		result2 error
	}{result1, result2}
}

func (fake *DBConn) PrepareContextReturnsOnCall(i int, result1 *sql.Stmt, result2 error) {
	fake.prepareContextMutex.Lock()
	defer fake.prepareContextMutex.Unlock()
	fake.PrepareContextStub = nil
	if fake.prepareContextReturnsOnCall == nil {
		fake.prepareContextReturnsOnCall = make(map[int]struct {
			result1 *sql.Stmt
			result2 error
		})
	}
	fake.prepareContextReturnsOnCall[i] = struct {
		result1 *sql.Stmt
		result2 error
	}{result1, result2}
}

func (fake *DBConn) QueryContext(arg1 context.Context, arg2 string, arg3 ...interface{}) (*sql.Rows, error) {
	fake.queryContextMutex.Lock()
	ret, specificReturn := fake.queryContextReturnsOnCall[len(fake.queryContextArgsForCall)]
	fake.queryContextArgsForCall = append(fake.queryContextArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("QueryContext", []interface{}{arg1, arg2, arg3})
	fake.queryContextMutex.Unlock()
	if fake.QueryContextStub != nil {
		return fake.QueryContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.queryContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *DBConn) QueryContextCallCount() int {
	fake.queryContextMutex.RLock()
	defer fake.queryContextMutex.RUnlock()
	return len(fake.queryContextArgsForCall)
}

func (fake *DBConn) QueryContextCalls(stub func(context.Context, string, ...interface{}) (*sql.Rows, error)) {
	fake.queryContextMutex.Lock()
	defer fake.queryContextMutex.Unlock()
	fake.QueryContextStub = stub
}

func (fake *DBConn) QueryContextArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.queryContextMutex.RLock()
	defer fake.queryContextMutex.RUnlock()
	argsForCall := fake.queryContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *DBConn) QueryContextReturns(result1 *sql.Rows, result2 error) {
	fake.queryContextMutex.Lock()
	defer fake.queryContextMutex.Unlock()
	fake.QueryContextStub = nil
	fake.queryContextReturns = struct {
		result1 *sql.Rows
		result2 error
	}{result1, result2}
}

func (fake *DBConn) QueryContextReturnsOnCall(i int, result1 *sql.Rows, result2 error) {
	fake.queryContextMutex.Lock()
	defer fake.queryContextMutex.Unlock()
	fake.QueryContextStub = nil
	if fake.queryContextReturnsOnCall == nil {
		fake.queryContextReturnsOnCall = make(map[int]struct {
			result1 *sql.Rows
			result2 error
		})
	}
	fake.queryContextReturnsOnCall[i] = struct {
		result1 *sql.Rows
		result2 error
	}{result1, result2}
}

func (fake *DBConn) QueryRowContext(arg1 context.Context, arg2 string, arg3 ...interface{}) *sql.Row {
	fake.queryRowContextMutex.Lock()
	ret, specificReturn := fake.queryRowContextReturnsOnCall[len(fake.queryRowContextArgsForCall)]
	fake.queryRowContextArgsForCall = append(fake.queryRowContextArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("QueryRowContext", []interface{}{arg1, arg2, arg3})
	fake.queryRowContextMutex.Unlock()
	if fake.QueryRowContextStub != nil {
		return fake.QueryRowContextStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.queryRowContextReturns
	return fakeReturns.result1
}

func (fake *DBConn) QueryRowContextCallCount() int {
	fake.queryRowContextMutex.RLock()
	defer fake.queryRowContextMutex.RUnlock()
	return len(fake.queryRowContextArgsForCall)
}

func (fake *DBConn) QueryRowContextCalls(stub func(context.Context, string, ...interface{}) *sql.Row) {
	fake.queryRowContextMutex.Lock()
	defer fake.queryRowContextMutex.Unlock()
	fake.QueryRowContextStub = stub
}

func (fake *DBConn) QueryRowContextArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.queryRowContextMutex.RLock()
	defer fake.queryRowContextMutex.RUnlock()
	argsForCall := fake.queryRowContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *DBConn) QueryRowContextReturns(result1 *sql.Row) {
	fake.queryRowContextMutex.Lock()
	defer fake.queryRowContextMutex.Unlock()
	fake.QueryRowContextStub = nil
	fake.queryRowContextReturns = struct {
		result1 *sql.Row
	}{result1}
}

func (fake *DBConn) QueryRowContextReturnsOnCall(i int, result1 *sql.Row) {
	fake.queryRowContextMutex.Lock()
	defer fake.queryRowContextMutex.Unlock()
	fake.QueryRowContextStub = nil
	if fake.queryRowContextReturnsOnCall == nil {
		fake.queryRowContextReturnsOnCall = make(map[int]struct {
			result1 *sql.Row
		})
	}
	fake.queryRowContextReturnsOnCall[i] = struct {
		result1 *sql.Row
	}{result1}
}

func (fake *DBConn) SetConnMaxLifetime(arg1 time.Duration) {
	fake.setConnMaxLifetimeMutex.Lock()
	fake.setConnMaxLifetimeArgsForCall = append(fake.setConnMaxLifetimeArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	fake.recordInvocation("SetConnMaxLifetime", []interface{}{arg1})
	fake.setConnMaxLifetimeMutex.Unlock()
	if fake.SetConnMaxLifetimeStub != nil {
		fake.SetConnMaxLifetimeStub(arg1)
	}
}

func (fake *DBConn) SetConnMaxLifetimeCallCount() int {
	fake.setConnMaxLifetimeMutex.RLock()
	defer fake.setConnMaxLifetimeMutex.RUnlock()
	return len(fake.setConnMaxLifetimeArgsForCall)
}

func (fake *DBConn) SetConnMaxLifetimeCalls(stub func(time.Duration)) {
	fake.setConnMaxLifetimeMutex.Lock()
	defer fake.setConnMaxLifetimeMutex.Unlock()
	fake.SetConnMaxLifetimeStub = stub
}

func (fake *DBConn) SetConnMaxLifetimeArgsForCall(i int) time.Duration {
	fake.setConnMaxLifetimeMutex.RLock()
	defer fake.setConnMaxLifetimeMutex.RUnlock()
	argsForCall := fake.setConnMaxLifetimeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *DBConn) SetMaxIdleConns(arg1 int) {
	fake.setMaxIdleConnsMutex.Lock()
	fake.setMaxIdleConnsArgsForCall = append(fake.setMaxIdleConnsArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("SetMaxIdleConns", []interface{}{arg1})
	fake.setMaxIdleConnsMutex.Unlock()
	if fake.SetMaxIdleConnsStub != nil {
		fake.SetMaxIdleConnsStub(arg1)
	}
}

func (fake *DBConn) SetMaxIdleConnsCallCount() int {
	fake.setMaxIdleConnsMutex.RLock()
	defer fake.setMaxIdleConnsMutex.RUnlock()
	return len(fake.setMaxIdleConnsArgsForCall)
}

func (fake *DBConn) SetMaxIdleConnsCalls(stub func(int)) {
	fake.setMaxIdleConnsMutex.Lock()
	defer fake.setMaxIdleConnsMutex.Unlock()
	fake.SetMaxIdleConnsStub = stub
}

func (fake *DBConn) SetMaxIdleConnsArgsForCall(i int) int {
	fake.setMaxIdleConnsMutex.RLock()
	defer fake.setMaxIdleConnsMutex.RUnlock()
	argsForCall := fake.setMaxIdleConnsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *DBConn) SetMaxOpenConns(arg1 int) {
	fake.setMaxOpenConnsMutex.Lock()
	fake.setMaxOpenConnsArgsForCall = append(fake.setMaxOpenConnsArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("SetMaxOpenConns", []interface{}{arg1})
	fake.setMaxOpenConnsMutex.Unlock()
	if fake.SetMaxOpenConnsStub != nil {
		fake.SetMaxOpenConnsStub(arg1)
	}
}

func (fake *DBConn) SetMaxOpenConnsCallCount() int {
	fake.setMaxOpenConnsMutex.RLock()
	defer fake.setMaxOpenConnsMutex.RUnlock()
	return len(fake.setMaxOpenConnsArgsForCall)
}

func (fake *DBConn) SetMaxOpenConnsCalls(stub func(int)) {
	fake.setMaxOpenConnsMutex.Lock()
	defer fake.setMaxOpenConnsMutex.Unlock()
	fake.SetMaxOpenConnsStub = stub
}

func (fake *DBConn) SetMaxOpenConnsArgsForCall(i int) int {
	fake.setMaxOpenConnsMutex.RLock()
	defer fake.setMaxOpenConnsMutex.RUnlock()
	argsForCall := fake.setMaxOpenConnsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *DBConn) Stats() sql.DBStats {
	fake.statsMutex.Lock()
	ret, specificReturn := fake.statsReturnsOnCall[len(fake.statsArgsForCall)]
	fake.statsArgsForCall = append(fake.statsArgsForCall, struct {
	}{})
	fake.recordInvocation("Stats", []interface{}{})
	fake.statsMutex.Unlock()
	if fake.StatsStub != nil {
		return fake.StatsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.statsReturns
	return fakeReturns.result1
}

func (fake *DBConn) StatsCallCount() int {
	fake.statsMutex.RLock()
	defer fake.statsMutex.RUnlock()
	return len(fake.statsArgsForCall)
}

func (fake *DBConn) StatsCalls(stub func() sql.DBStats) {
	fake.statsMutex.Lock()
	defer fake.statsMutex.Unlock()
	fake.StatsStub = stub
}

func (fake *DBConn) StatsReturns(result1 sql.DBStats) {
	fake.statsMutex.Lock()
	defer fake.statsMutex.Unlock()
	fake.StatsStub = nil
	fake.statsReturns = struct {
		result1 sql.DBStats
	}{result1}
}

func (fake *DBConn) StatsReturnsOnCall(i int, result1 sql.DBStats) {
	fake.statsMutex.Lock()
	defer fake.statsMutex.Unlock()
	fake.StatsStub = nil
	if fake.statsReturnsOnCall == nil {
		fake.statsReturnsOnCall = make(map[int]struct {
			result1 sql.DBStats
		})
	}
	fake.statsReturnsOnCall[i] = struct {
		result1 sql.DBStats
	}{result1}
}

func (fake *DBConn) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.beginTxMutex.RLock()
	defer fake.beginTxMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.connMutex.RLock()
	defer fake.connMutex.RUnlock()
	fake.driverMutex.RLock()
	defer fake.driverMutex.RUnlock()
	fake.execContextMutex.RLock()
	defer fake.execContextMutex.RUnlock()
	fake.pingContextMutex.RLock()
	defer fake.pingContextMutex.RUnlock()
	fake.prepareContextMutex.RLock()
	defer fake.prepareContextMutex.RUnlock()
	fake.queryContextMutex.RLock()
	defer fake.queryContextMutex.RUnlock()
	fake.queryRowContextMutex.RLock()
	defer fake.queryRowContextMutex.RUnlock()
	fake.setConnMaxLifetimeMutex.RLock()
	defer fake.setConnMaxLifetimeMutex.RUnlock()
	fake.setMaxIdleConnsMutex.RLock()
	defer fake.setMaxIdleConnsMutex.RUnlock()
	fake.setMaxOpenConnsMutex.RLock()
	defer fake.setMaxOpenConnsMutex.RUnlock()
	fake.statsMutex.RLock()
	defer fake.statsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *DBConn) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pggen.DBConn = new(DBConn)
